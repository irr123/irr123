<!doctype html><html lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>DI container vs. service template (generator) | Let’s talk ab...</title><meta name=description content="Let’s talk about building and evolving Golang services in the enterprise. We’ll explore two approaches: A Service Template (g..."><meta name=keywords content="golang,architecture,dependency injection,DI container,service template,microservices,software design patterns,software architecture,Golang dependency injection,DI vs service template,Golang microservices,Golang DI container,Go service generator,Golang project structure,Golang best practices,software scalability,Golang framework,inversion of control,Golang IoC,Golang DI example,Golang container pattern,microservices best practices,CI/CD for Golang,software quality management,Golang software templates"><meta name=author content="Ivan Bogomolov"><meta name=robots content="index,follow"><link rel=canonical href=https://bogomolov.work/blog/posts/golang-di-container-vs-service-template/><link rel=alternate type=application/rss+xml href=/index.xml title="The Archive"><link rel=icon type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=192x192 href=/android-chrome-192x192.png><link rel=icon type=image/png sizes=512x512 href=/android-chrome-512x512.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><meta property="og:title" content="DI container vs. service template (generator)"><meta property="og:description" content="Let’s talk about building and evolving Golang services in the enterprise. We’ll explore two approaches: A Service Template (generator) is a common approach for unifying and quickly bootstrapping new microservices. Its popularity is evident in the community, as demonstrated by examples such as: https://github.com/evrone/go-clean-template https://www.reddit.com/r/golang/comments/1h124ee/rate_my_go_project_template/ https://dev.to/protium/github-template-for-golang-services-3o27 https://www.youtube.com/watch?v=1ZbQS6pOlSQ Dependency injection (DI)1 is an approach where objects are constructed by passing pre-initialized components to them, rather than having the objects initialize those components themselves.2 DI container automates the dependency injection process. While not the most common approach for bootstrapping new services, it offers several advantages, which I will outline. # The problem The challenge is a timeless one: accelerating the delivery of value to production. From a technical perspective, this translates to several key requirements:"><meta property="og:type" content="website"><meta property="og:url" content="https://bogomolov.work/blog/posts/golang-di-container-vs-service-template/"><meta property="og:logo" content="https://bogomolov.work/img/the-archive.jpg"><meta property="og:image" content="https://bogomolov.work/blog/posts/golang-di-container-vs-service-template/morpheus.jpg"><meta name=twitter:card content="summary_large_image"><meta name=twitter:creator content="@_irr123"><meta property="twitter:domain" content="bogomolov.work"><meta property="twitter:url" content="https://bogomolov.work/blog/posts/golang-di-container-vs-service-template/"><meta name=twitter:title content="DI container vs. service template (generator)"><meta name=twitter:description content="Let’s talk about building and evolving Golang services in the enterprise. We’ll explore two approaches: A Service Template (generator) is a common approach for unifying and quickly bootstrapping new microservices. Its popularity is evident in the community, as demonstrated by examples such as: https://github.com/evrone/go-clean-template https://www.reddit.com/r/golang/comments/1h124ee/rate_my_go_project_template/ https://dev.to/protium/github-template-for-golang-services-3o27 https://www.youtube.com/watch?v=1ZbQS6pOlSQ Dependency injection (DI)1 is an approach where objects are constructed by passing pre-initialized components to them, rather than having the objects initialize those components themselves.2 DI container automates the dependency injection process. While not the most common approach for bootstrapping new services, it offers several advantages, which I will outline. # The problem The challenge is a timeless one: accelerating the delivery of value to production. From a technical perspective, this translates to several key requirements:"><meta name=twitter:image content="https://bogomolov.work/blog/posts/golang-di-container-vs-service-template/morpheus.jpg"><meta name=theme-color content="#000000"><link rel=stylesheet href=/css/styles.bundle.min.90060f45473ec93e674034680b680274ae5f893449bb950a0ca1088a645c90619afef9c501deba015571ea89bd800d6499499a029a5957a35780fb69f8869165.css integrity="sha512-kAYPRUc+yT5nQDRoC2gCdK5fiTRJu5UKDKEIimRckGGa/vnFAd66AVVx6om9gA1kmUmaAppZV6NXgPtp+IaRZQ=="></head><body a=auto><main class=page-content aria-label=Content><div class=w><div class=post-meta><p><button type=button class=back-button aria-label="Go back" title="Go back" onclick='window.history.length>2?window.history.back():window.location.href="/blog/"' class=back-button>
← Back</button></p><p><time datetime=2025-02-21T06:31:02+00:00>2025-02-21</time></p></div><header><h1>DI container vs. service template (generator)</h1></header><article><p>Let’s talk about building and evolving Golang services in the enterprise. We’ll
explore two approaches:</p><figure><a href=/blog/posts/golang-di-container-vs-service-template/morpheus.jpg target=_blank><picture><source srcset=/blog/posts/golang-di-container-vs-service-template/morpheus_hu_436c7de016324227.webp type=image/webp><source srcset=/blog/posts/golang-di-container-vs-service-template/morpheus_hu_db19bce7acb181ab.jpg type=image/jpeg><img src=/blog/posts/golang-di-container-vs-service-template/morpheus_hu_db19bce7acb181ab.jpg alt="Create image illustration in anime style with Morpheus from Matrix suggesting you blue and red pills" loading=eager fetchpriority=high decoding=sync></picture></a></figure><ul><li>A <em>Service Template (generator)</em> is a common approach for unifying and quickly
bootstrapping new microservices. Its popularity is evident in the community,
as demonstrated by examples such as:<ul><li><a href=https://github.com/evrone/go-clean-template target=_blank rel="noopener noreferrer">https://github.com/evrone/go-clean-template</a></li><li><a href=https://www.reddit.com/r/golang/comments/1h124ee/rate_my_go_project_template/ target=_blank rel="noopener noreferrer">https://www.reddit.com/r/golang/comments/1h124ee/rate_my_go_project_template/</a></li><li><a href=https://dev.to/protium/github-template-for-golang-services-3o27 target=_blank rel="noopener noreferrer">https://dev.to/protium/github-template-for-golang-services-3o27</a></li><li><a href="https://www.youtube.com/watch?v=1ZbQS6pOlSQ" target=_blank rel="noopener noreferrer">https://www.youtube.com/watch?v=1ZbQS6pOlSQ</a></li></ul></li><li><a href=https://grokipedia.com/page/Dependency_injection target=_blank rel="noopener noreferrer">Dependency injection</a>
(<em>DI</em>)<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup> is an approach where objects are constructed by passing
pre-initialized components to them, rather than having the objects initialize
those components themselves.<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup><ul><li><a href=https://github.com/irr123/di target=_blank rel="noopener noreferrer">DI container</a> automates the dependency
injection process. While not the most common approach for bootstrapping new
services, it offers several advantages, which I will outline.</li></ul></li></ul><h2 id=the-problem><a href=#the-problem>#</a> The problem</h2><p>The challenge is a timeless one: accelerating the delivery of value to
production. From a technical perspective, this translates to several key
requirements:</p><ul><li><strong>Pre-built components:</strong> These eliminate the need to reinvent the wheel,
saving valuable development time.</li><li><strong>Consistent service structure:</strong> A uniform structure reduces
context-switching overhead.</li><li><strong>Unified interaction interfaces:</strong> Standardized configuration, logging, and
metrics save significant time for operation guys.</li></ul><h3 id=examples><a href=#examples>#</a> Examples</h3><p>Imagine a company with a few internal services looking to expand and release
more. Or consider an outsourcing company developing services for external
clients and aiming to increase its customer base. In both scenarios, efficiency
is paramount, and directly related to the problems highlighted earlier.</p><p>When examining individual services, we often find that, regardless of the
specific
<a href=https://www.oreilly.com/library/view/software-architecture-patterns/9781491971437/ch01.html target=_blank rel="noopener noreferrer">layered architecture</a>
employed (e.g.,
<a href=https://jeffreypalermo.com/2008/07/the-onion-architecture-part-1/ target=_blank rel="noopener noreferrer">Onion</a>,
<a href=https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html target=_blank rel="noopener noreferrer">Clean</a>,
or
<a href=https://grokipedia.com/page/Hexagonal_architecture_%28software%29 target=_blank rel="noopener noreferrer">Hexagonal</a><sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>)
outer layers tend to be shared across services, whereas the core business logic
remains distinct<sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup>. Specifically, elements such as observability tools,
database connections, and message broker clients can be identical. These
constitute the essential pre-built components and contribute to a consistent
service structure. A unified interaction interface emerges from the standardized
configuration of these pre-built components. For example, a shared database
connection operates with consistent configuration parameters, providing uniform
logging, metrics, and deployment procedures.</p><h4 id=straightforward-implementation><a href=#straightforward-implementation>#</a> Straightforward implementation</h4><p>A common approach is to consolidate all shared code into one or more shared
libraries. A service template can then be created to generate new services that
include these libraries as dependencies, along with pre-prepared boilerplate
code.</p><p>Pros:</p><ul><li>This approach works.</li></ul><p>Cons:</p><ul><li>While addressing initial setup challenges, this method introduces a new
problem: a continuously evolving template will inevitably diverge from the
services it generates.</li><li>The “templating” nature of this approach makes the template itself difficult
to test and analyze with static analysis tools.</li></ul><h4 id=di-container-to-the-rescue><a href=#di-container-to-the-rescue>#</a> DI container to the Rescue</h4><p>Instead of relying on templates, we can retain the shared library approach and
encapsulate all pre-built components within a container. This allows developers
to focus solely on adding the business logic, adhering to the chosen layered
architecture:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:red>import</span> (
</span></span><span style=display:flex><span>    <span style=color:#87ceeb>&#34;github.com/irr123/di&#34;</span>
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    <span style=color:#87ceeb>&#34;internal.lib/bootstrap&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:red>func</span> <span style=color:#ff0>main</span>() {
</span></span><span style=display:flex><span>    c := di.<span style=color:#ff0>New</span>()
</span></span><span style=display:flex><span>    bootstrap.<span style=color:#ff0>PutItAllTogether</span>(c)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    di.<span style=color:#ff0>Set</span>(c, di.<span style=color:#ff0>OptMiddleware</span>(<span style=color:red>func</span>(e *echo.Echo) (*echo.Echo, <span style=color:violet>error</span>) {
</span></span><span style=display:flex><span>        <span style=color:#0f0>// echo srv here is already fully configured and only needs to attach handlers</span>
</span></span><span style=display:flex><span>        e.<span style=color:#ff0>GET</span>(<span style=color:#87ceeb>&#34;/&#34;</span>, <span style=color:red>func</span>(c echo.Context) <span style=color:violet>error</span> {
</span></span><span style=display:flex><span>            <span style=color:red>return</span> c.<span style=color:#ff0>JSON</span>(http.StatusOK, <span style=color:#87ceeb>&#34;&#34;</span>)
</span></span><span style=display:flex><span>        })
</span></span><span style=display:flex><span>    }))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    di.Get[*echo.Echo](c).<span style=color:#ff0>Start</span>(<span style=color:#87ceeb>&#34;:8080&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><a href=https://go.dev/play/p/vxWijBAc3lC target=_blank rel="noopener noreferrer">Live example</a>.</p><p>This approach reduces maintenance costs because it involves well-typed, valid
code (without templating complexities) that can be effectively covered by
quality checks. Furthermore, backward compatibility is maintained by following
standard coding practices.</p><h2 id=finishing-uncovered-parts><a href=#finishing-uncovered-parts>#</a> Finishing Uncovered Parts</h2><p>Continuing the comparison between containers and templates, it’s worth noting
that templates can offer a more comprehensive initial setup. This might include
project layout, deployment scripts, CI/CD pipelines, VCS hooks, monitoring
dashboards, alerts, and other elements. It’s important to understand that
templates provide these features only at the initial project creation and do not
enforce them during subsequent project evolution (whereas containers maintain
consistency).</p><p>In conclusion good to know that these two approaches are not mutually exclusive
and this article aims to explore the available options.</p><hr><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p><a href=https://grokipedia.com/page/Inversion_of_control target=_blank rel="noopener noreferrer"><em>IoC</em></a> is close but not
the same concept, don’t be confused. <em>DI</em> is a programming technique, while
<em>IoC</em> is a design principle covered broader idea (let me know and I’ll think
about post on this topic).&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>I intentionally will avoid word “class”.&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p>Does Dr.Alistair Cockburn not pay for
<a href=https://alistair.cockburn.us target=_blank rel="noopener noreferrer">hosting</a>?&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4><p>It’s important point, imagine opposite way if you’re sharing business logic
between services, what’s a purpose of separation than?&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></article></div></main><footer class=site-footer><a target=_blank rel="noopener noreferrer external" href=https://newsletter.bogomolov.work>Newsletter</a> | <a target=_blank href=/index.xml>RSS</a></footer><script>(function(){var e=document.createElement("script");e.src="https://unpkg.com/@grafana/faro-web-sdk@2/dist/bundle/faro-web-sdk.iife.js",e.onload=()=>{window.GrafanaFaroWebSdk.initializeFaro({url:"https://faro-collector-prod-eu-west-2.grafana.net/collect/280a442f2880e6eb5e953a7169416ccf",app:{name:"blog",version:"1.0.0",environment:"production"},sessionTracking:{samplingRate:1,persistent:!0}});var e=document.createElement("script");e.src="https://unpkg.com/@grafana/faro-web-tracing@2/dist/bundle/faro-web-tracing.iife.js",e.onload=()=>{window.GrafanaFaroWebSdk.faro.instrumentations.add(new window.GrafanaFaroWebTracing.TracingInstrumentation)},document.head.appendChild(e)},document.head.appendChild(e)})()</script></body></html>
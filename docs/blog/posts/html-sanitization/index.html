<!doctype html><html lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>HTML sanitization: Avoiding the double-encoding issue | Once ...</title><meta name=description content="Once upon a time, I went through another security audit on a project that wasnâ€™t particularly old but had passed through the ..."><meta name=keywords content="HTML Sanitization,XSS,Cross-Site Scripting,Double Encoding,Double Escaping,React,Next.js,NestJS,Web Security,Sanitize on Ingest,Sanitize on Output,Unicode,Character Entities,Data Transformation,System Architecture,Security Audit"><meta name=author content="Ivan Bogomolov"><meta name=robots content="index,follow"><link rel=canonical href=https://bogomolov.work/blog/posts/html-sanitization/><link rel=alternate type=application/rss+xml href=/blog/index.xml title="The Archive"><link rel=icon type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=192x192 href=/android-chrome-192x192.png><link rel=icon type=image/png sizes=512x512 href=/android-chrome-512x512.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><meta property="og:title" content="HTML sanitization: Avoiding the double-encoding issue"><meta property="og:description" content="Once upon a time, I went through another security audit on a project that wasnâ€™t particularly old but had passed through the hands of several teams. After the first round of penetration testing, the auditing team found a lack of data sanitization on the backend side.
"><meta property="og:type" content="website"><meta property="og:url" content="https://bogomolov.work/blog/posts/html-sanitization/"><meta property="og:logo" content="https://bogomolov.work/blog/img/the-archive.jpg"><meta property="og:image" content="https://bogomolov.work/blog/posts/html-sanitization/sanitization.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:site content="@_irr123"><meta property="twitter:domain" content="bogomolov.work"><meta property="twitter:url" content="https://bogomolov.work/blog/posts/html-sanitization/"><meta name=twitter:title content="HTML sanitization: Avoiding the double-encoding issue"><meta name=twitter:description content="Once upon a time, I went through another security audit on a project that wasnâ€™t particularly old but had passed through the hands of several teams. After the first round of penetration testing, the auditing team found a lack of data sanitization on the backend side.
"><meta name=twitter:image content="https://bogomolov.work/blog/posts/html-sanitization/sanitization.png"><meta name=theme-color content="#000000"><link rel=stylesheet href=/blog/css/styles.bundle.min.6dfd4bffb4fc60f9fc9061ace4309feccf93d5aefab8d8e2ad003d757bd5f34194e43fbde5acefb17dd532099a054926df6c8f38ff0bb741520a4064a1d4eb5c.css integrity="sha512-bf1L/7T8YPn8kGGs5DCf7M+T1a76uNjirQA9dXvV80GU5D+95azvsX3VMgmaBUkm32yPOP8Lt0FSCkBkodTrXA=="><link rel=preconnect href=https://www.googletagmanager.com><link rel=preconnect href=https://pagead2.googlesyndication.com><link rel=preconnect href=https://mc.yandex.ru><link rel=preconnect href=https://connect.facebook.net></head><body a=auto><main class=page-content aria-label=Content><div class=w><div class=post-meta><a href=/blog/ aria-label="Back to Index" title="Back to Index">â† Back</a><p><time datetime=2025-09-05T08:13:44+00:00>2025-09-05</time></p></div><h1>HTML sanitization: Avoiding the double-encoding issue</h1><article><p>Once upon a time, I went through another security audit on a project that wasnâ€™t
particularly old but had passed through the hands of several teams. After the
first round of penetration testing, the auditing team found a lack of data
sanitization on the backend side.</p><p>With proof. Quite disappointing.</p><figure><a href=/blog/posts/html-sanitization/sanitization.png target=_blank><picture><source srcset=/blog/posts/html-sanitization/sanitization_hu_17ed6facb78e59e8.webp type=image/webp><source srcset=/blog/posts/html-sanitization/sanitization_hu_2c526f5f8add7498.jpg type=image/jpeg><img src=/blog/posts/html-sanitization/sanitization_hu_2c526f5f8add7498.jpg alt="data processing pipe" loading=lazy decoding=async></picture></a></figure><blockquote><p><strong>Warning:</strong> This article is NOT a recommendation to abandon standard HTML
entity encoding. This method should only be considered by those who fully
understand the security implications and are facing the exact double-encoding
problem described here.</p></blockquote><h2 id=related-internals><a href=#related-internals>#</a> Related Internals</h2><p>As a result, security auditing team presented us with demands:</p><ol><li><p>Sanitize all data coming from client to server on server side;</p><ul><li><em>Sanitize on Ingest</em>: A â€œdefense in depthâ€ strategy. Never trust user input
and clean it before it even touches your database. Classic security
requirement.</li></ul></li><li><p>Sanitize all data coming from server to client on client side;</p><ul><li><em>Sanitize on Output</em>: The modern web development approach â€” sanitize data
for the specific context itâ€™s being used in (e.g., HTML, CSS, a URL) at the
last possible moment. This is considered the most effective way to prevent
XSS.</li></ul></li></ol><p>Our tech stack was a fairly standard setup: a few microservices built with
NestJS and a Next.js frontend. And <em>Sanitize on Output</em> is a standard security
practice in React (which powers Next.js); it already protects against HTML
injection by default by sanitizing all rendered output. Disabling this is a
major anti-pattern.</p><h2 id=the-issue><a href=#the-issue>#</a> The Issue</h2><p>It wasnâ€™t a big deal to implement sanitization on the server side, so I did it
and started storing strings with <code>&amp;amp;</code> instead of the literal character <code>&</code> in
the database. However, this created a classic double-escaping problem. Because
React also escapes output, the <code>&amp;amp;</code> I was carefully storing in the database
was rendered literally on the screen as <code>&amp;amp;</code>. The browser never turned it
back into an <code>&</code>.</p><p>Every online guide and AI assistant suggested the same thing: â€œOnly sanitize on
outputâ€! But I couldnâ€™t do that; the security teamâ€™s requirement to sanitize on
ingest was non-negotiable.</p><p>And the interesting idea landed in my head: Why, in <strong>2025</strong>, we are still using
<a href=https://grokipedia.com/page/Character_encodings_in_HTML#character-references target=_blank rel="noopener noreferrer">character entities</a>
instead of <em>raw Unicode characters</em>?</p><p>For simplicity, Iâ€™ll provide a list for comparison (not all of them have to be
used):</p><table><thead><tr><th style=text-align:left>Character entity</th><th style=text-align:left>Unicode symbol</th><th style=text-align:center>Security critical</th></tr></thead><tbody><tr><td style=text-align:left><code>&amp;hellip;</code></td><td style=text-align:left><code>â€¦</code></td><td style=text-align:center></td></tr><tr><td style=text-align:left><code>&amp;mdash;</code></td><td style=text-align:left><code>â€”</code></td><td style=text-align:center></td></tr><tr><td style=text-align:left><code>&amp;ndash;</code></td><td style=text-align:left><code>â€“</code></td><td style=text-align:center></td></tr><tr><td style=text-align:left><code>&amp;laquo;</code></td><td style=text-align:left><code>Â«</code></td><td style=text-align:center></td></tr><tr><td style=text-align:left><code>&amp;ldquo;</code></td><td style=text-align:left><code>â€œ</code></td><td style=text-align:center></td></tr><tr><td style=text-align:left><code>&amp;lsquo;</code></td><td style=text-align:left><code>â€˜</code></td><td style=text-align:center></td></tr><tr><td style=text-align:left><code>&amp;raquo;</code></td><td style=text-align:left><code>Â»</code></td><td style=text-align:center></td></tr><tr><td style=text-align:left><code>&amp;rdquo;</code></td><td style=text-align:left><code>â€</code></td><td style=text-align:center></td></tr><tr><td style=text-align:left><code>&amp;rsquo;</code></td><td style=text-align:left><code>â€™</code></td><td style=text-align:center></td></tr><tr><td style=text-align:left><code>&amp;amp;</code></td><td style=text-align:left><code>ï¼†</code></td><td style=text-align:center>âœ…</td></tr><tr><td style=text-align:left><code>&amp;lt;</code></td><td style=text-align:left><code>ï¼œ</code></td><td style=text-align:center>âœ…</td></tr><tr><td style=text-align:left><code>&amp;gt;</code></td><td style=text-align:left><code>ï¼</code></td><td style=text-align:center>âœ…</td></tr></tbody></table><p>The goal was reached â€” the database now contained only <em>safe</em> symbols, and the
UI represented them nicely. But at what price, you may ask?</p><p><strong>Fun fact</strong>: Single UTF symbol requires less space compared with 3+ ASCII
symbols in utf encoding.</p><h2 id=trade-offs-and-considerations><a href=#trade-offs-and-considerations>#</a> Trade-offs and Considerations</h2><ul><li>First, legacy systems: If youâ€™re still using KOI8-R and similar, this isnâ€™t
for you (legacy email clients, for example). Resign yourself to it.</li><li>This approach has to work consistently across the entire backend.<ul><li>Any tech decision has to work consistently, isnâ€™t it?</li></ul></li><li>Database content isnâ€™t pure user input, but is it a real problem?<ul><li>Youâ€™ll need to migrate old data, âœ…</li><li>I have to write
<code>SELECT * FROM somewhere WHERE data = "some dataï¼†another data"</code>, which
could be an issue only for analytical purposes ğŸ¤”<ul><li>Anyway, Iâ€™ll set up a custom tokenizer in Typesense/Elasticsearch.</li></ul></li><li>But itâ€™s already prepared to be exported into CSV without additional
escaping (as a joke).</li></ul></li><li>Iâ€™m not a mobile dev, and we donâ€™t have mobile apps yet â€” weâ€™ll see (just
use proper encoding and modern fonts, not from the dinosaur era ğŸ¤·).</li><li>Probably the most underrated point: This process is more like <em>data
transformation</em> than <em>sanitization</em>.</li></ul><h2 id=conclusion><a href=#conclusion>#</a> Conclusion</h2><p>So, is this an ugly hack or an elegant solution?</p><p>I would count it as an elegant trade-off. In a perfect world, we would only
sanitize on output. But we donâ€™t operate in a perfect world; (un)fortunately we
operate with real-world constraints.</p></article></div></main><footer class=site-footer><a target=_blank rel="noopener noreferrer external" href=https://newsletter.bogomolov.work>Newsletter</a> | <a target=_blank href=/blog/index.xml>RSS</a></footer><script async src="https://www.googletagmanager.com/gtag/js?id=G-950H2PH48S"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-950H2PH48S")</script><script>(function(e,t,n,s,o,i,a){e[o]=e[o]||function(){(e[o].a=e[o].a||[]).push(arguments)},e[o].l=1*new Date;for(var r=0;r<document.scripts.length;r++)if(document.scripts[r].src===s)return;i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)})(window,document,"script","https://mc.yandex.ru/metrika/tag.js","ym"),ym(100343675,"init",{clickmap:!0,trackLinks:!0,accurateTrackBounce:!0})</script><noscript><div><img src=https://mc.yandex.ru/watch/100343675 style=position:absolute;left:-9999px alt></div></noscript><script>!function(e,t,n,s,o,i,a){if(e.fbq)return;o=e.fbq=function(){o.callMethod?o.callMethod.apply(o,arguments):o.queue.push(arguments)},e._fbq||(e._fbq=o),o.push=o,o.loaded=!0,o.version="2.0",o.queue=[],i=t.createElement(n),i.async=!0,i.src=s,a=t.getElementsByTagName(n)[0],a.parentNode.insertBefore(i,a)}(window,document,"script","https://connect.facebook.net/en_US/fbevents.js"),fbq("init","2627430184120255"),fbq("track","PageView")</script><noscript><img alt height=1 width=1 style=display:none src="https://www.facebook.com/tr?id=2627430184120255&ev=PageView&noscript=1"></noscript></body></html>